// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() httpExternalException,
    required TResult Function() httpUnAuthorizedError,
    required TResult Function() noConnectionFailure,
    required TResult Function() cacheFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HttpExternalException value)
        httpExternalException,
    required TResult Function(_HttpUnAuthorizedError value)
        httpUnAuthorizedError,
    required TResult Function(_NoConnectionFailure value) noConnectionFailure,
    required TResult Function(_CacheFailure value) cacheFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$FailureCopyWithImpl<$Res> implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  final Failure _value;
  // ignore: unused_field
  final $Res Function(Failure) _then;
}

/// @nodoc
abstract class _$$_HttpExternalExceptionCopyWith<$Res> {
  factory _$$_HttpExternalExceptionCopyWith(_$_HttpExternalException value,
          $Res Function(_$_HttpExternalException) then) =
      __$$_HttpExternalExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_HttpExternalExceptionCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements _$$_HttpExternalExceptionCopyWith<$Res> {
  __$$_HttpExternalExceptionCopyWithImpl(_$_HttpExternalException _value,
      $Res Function(_$_HttpExternalException) _then)
      : super(_value, (v) => _then(v as _$_HttpExternalException));

  @override
  _$_HttpExternalException get _value =>
      super._value as _$_HttpExternalException;
}

/// @nodoc

class _$_HttpExternalException implements _HttpExternalException {
  const _$_HttpExternalException();

  @override
  String toString() {
    return 'Failure.httpExternalException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_HttpExternalException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() httpExternalException,
    required TResult Function() httpUnAuthorizedError,
    required TResult Function() noConnectionFailure,
    required TResult Function() cacheFailure,
  }) {
    return httpExternalException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
  }) {
    return httpExternalException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
    required TResult orElse(),
  }) {
    if (httpExternalException != null) {
      return httpExternalException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HttpExternalException value)
        httpExternalException,
    required TResult Function(_HttpUnAuthorizedError value)
        httpUnAuthorizedError,
    required TResult Function(_NoConnectionFailure value) noConnectionFailure,
    required TResult Function(_CacheFailure value) cacheFailure,
  }) {
    return httpExternalException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
  }) {
    return httpExternalException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
    required TResult orElse(),
  }) {
    if (httpExternalException != null) {
      return httpExternalException(this);
    }
    return orElse();
  }
}

abstract class _HttpExternalException implements Failure {
  const factory _HttpExternalException() = _$_HttpExternalException;
}

/// @nodoc
abstract class _$$_HttpUnAuthorizedErrorCopyWith<$Res> {
  factory _$$_HttpUnAuthorizedErrorCopyWith(_$_HttpUnAuthorizedError value,
          $Res Function(_$_HttpUnAuthorizedError) then) =
      __$$_HttpUnAuthorizedErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_HttpUnAuthorizedErrorCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements _$$_HttpUnAuthorizedErrorCopyWith<$Res> {
  __$$_HttpUnAuthorizedErrorCopyWithImpl(_$_HttpUnAuthorizedError _value,
      $Res Function(_$_HttpUnAuthorizedError) _then)
      : super(_value, (v) => _then(v as _$_HttpUnAuthorizedError));

  @override
  _$_HttpUnAuthorizedError get _value =>
      super._value as _$_HttpUnAuthorizedError;
}

/// @nodoc

class _$_HttpUnAuthorizedError implements _HttpUnAuthorizedError {
  const _$_HttpUnAuthorizedError();

  @override
  String toString() {
    return 'Failure.httpUnAuthorizedError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_HttpUnAuthorizedError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() httpExternalException,
    required TResult Function() httpUnAuthorizedError,
    required TResult Function() noConnectionFailure,
    required TResult Function() cacheFailure,
  }) {
    return httpUnAuthorizedError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
  }) {
    return httpUnAuthorizedError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
    required TResult orElse(),
  }) {
    if (httpUnAuthorizedError != null) {
      return httpUnAuthorizedError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HttpExternalException value)
        httpExternalException,
    required TResult Function(_HttpUnAuthorizedError value)
        httpUnAuthorizedError,
    required TResult Function(_NoConnectionFailure value) noConnectionFailure,
    required TResult Function(_CacheFailure value) cacheFailure,
  }) {
    return httpUnAuthorizedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
  }) {
    return httpUnAuthorizedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
    required TResult orElse(),
  }) {
    if (httpUnAuthorizedError != null) {
      return httpUnAuthorizedError(this);
    }
    return orElse();
  }
}

abstract class _HttpUnAuthorizedError implements Failure {
  const factory _HttpUnAuthorizedError() = _$_HttpUnAuthorizedError;
}

/// @nodoc
abstract class _$$_NoConnectionFailureCopyWith<$Res> {
  factory _$$_NoConnectionFailureCopyWith(_$_NoConnectionFailure value,
          $Res Function(_$_NoConnectionFailure) then) =
      __$$_NoConnectionFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NoConnectionFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements _$$_NoConnectionFailureCopyWith<$Res> {
  __$$_NoConnectionFailureCopyWithImpl(_$_NoConnectionFailure _value,
      $Res Function(_$_NoConnectionFailure) _then)
      : super(_value, (v) => _then(v as _$_NoConnectionFailure));

  @override
  _$_NoConnectionFailure get _value => super._value as _$_NoConnectionFailure;
}

/// @nodoc

class _$_NoConnectionFailure implements _NoConnectionFailure {
  const _$_NoConnectionFailure();

  @override
  String toString() {
    return 'Failure.noConnectionFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NoConnectionFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() httpExternalException,
    required TResult Function() httpUnAuthorizedError,
    required TResult Function() noConnectionFailure,
    required TResult Function() cacheFailure,
  }) {
    return noConnectionFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
  }) {
    return noConnectionFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
    required TResult orElse(),
  }) {
    if (noConnectionFailure != null) {
      return noConnectionFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HttpExternalException value)
        httpExternalException,
    required TResult Function(_HttpUnAuthorizedError value)
        httpUnAuthorizedError,
    required TResult Function(_NoConnectionFailure value) noConnectionFailure,
    required TResult Function(_CacheFailure value) cacheFailure,
  }) {
    return noConnectionFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
  }) {
    return noConnectionFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
    required TResult orElse(),
  }) {
    if (noConnectionFailure != null) {
      return noConnectionFailure(this);
    }
    return orElse();
  }
}

abstract class _NoConnectionFailure implements Failure {
  const factory _NoConnectionFailure() = _$_NoConnectionFailure;
}

/// @nodoc
abstract class _$$_CacheFailureCopyWith<$Res> {
  factory _$$_CacheFailureCopyWith(
          _$_CacheFailure value, $Res Function(_$_CacheFailure) then) =
      __$$_CacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CacheFailureCopyWithImpl<$Res> extends _$FailureCopyWithImpl<$Res>
    implements _$$_CacheFailureCopyWith<$Res> {
  __$$_CacheFailureCopyWithImpl(
      _$_CacheFailure _value, $Res Function(_$_CacheFailure) _then)
      : super(_value, (v) => _then(v as _$_CacheFailure));

  @override
  _$_CacheFailure get _value => super._value as _$_CacheFailure;
}

/// @nodoc

class _$_CacheFailure implements _CacheFailure {
  const _$_CacheFailure();

  @override
  String toString() {
    return 'Failure.cacheFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() httpExternalException,
    required TResult Function() httpUnAuthorizedError,
    required TResult Function() noConnectionFailure,
    required TResult Function() cacheFailure,
  }) {
    return cacheFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
  }) {
    return cacheFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? httpExternalException,
    TResult Function()? httpUnAuthorizedError,
    TResult Function()? noConnectionFailure,
    TResult Function()? cacheFailure,
    required TResult orElse(),
  }) {
    if (cacheFailure != null) {
      return cacheFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HttpExternalException value)
        httpExternalException,
    required TResult Function(_HttpUnAuthorizedError value)
        httpUnAuthorizedError,
    required TResult Function(_NoConnectionFailure value) noConnectionFailure,
    required TResult Function(_CacheFailure value) cacheFailure,
  }) {
    return cacheFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
  }) {
    return cacheFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HttpExternalException value)? httpExternalException,
    TResult Function(_HttpUnAuthorizedError value)? httpUnAuthorizedError,
    TResult Function(_NoConnectionFailure value)? noConnectionFailure,
    TResult Function(_CacheFailure value)? cacheFailure,
    required TResult orElse(),
  }) {
    if (cacheFailure != null) {
      return cacheFailure(this);
    }
    return orElse();
  }
}

abstract class _CacheFailure implements Failure {
  const factory _CacheFailure() = _$_CacheFailure;
}
